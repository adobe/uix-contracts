/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

/**
 * AST parsers are hard and looking mind-blowing
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * Edit the test instead and ask copilot to adjust this file accordingly.
 * Parsers are needed for computers so let them do the work.
 */

import * as ts from "typescript";

export function compareTypeStrings(
  sourceA: string,
  sourceB: string,
  opts: { verbose?: boolean } = {},
): boolean {
  const fileA = "memoryA.ts";
  const fileB = "memoryB.ts";
  const sources: Record<string, string> = {
    [fileA]: sourceA,
    [fileB]: sourceB,
  } as Record<string, string>;
  const program = ts.createProgram(
    [fileA, fileB],
    {
      allowJs: false,
      declaration: false,
      target: ts.ScriptTarget.ESNext,
      module: ts.ModuleKind.CommonJS,
    },
    {
      ...ts.createCompilerHost({}),
      getSourceFile: (fileName: string, languageVersion) =>
        ts.createSourceFile(
          fileName,
          sources[fileName] || "",
          languageVersion,
          true,
        ),
      readFile: (fileName: string) => sources[fileName] || "",
      fileExists: (fileName: string) => !!sources[fileName],
    },
  );
  const checker = program.getTypeChecker();
  const typesA = getExportedTypes(fileA, program, checker);
  const typesB = getExportedTypes(fileB, program, checker);
  let hasError = false;
  for (const key of Object.keys(typesA)) {
    if (!(key in typesB)) {
      if (opts.verbose)
        console.error(
          `Type '${key}' is exported in previous version but missing in current version`,
        );
      hasError = true;
      continue;
    }
    const errors = compareTypes(
      typesA[key],
      typesB[key],
      checker,
      [key],
      opts.verbose,
    );
    if (errors.length) {
      hasError = true;
      if (opts.verbose)
        console.error(
          `âœ– Type '${key}' in current version is not compatible with previous version:\n${errors.map((e) => "  - " + e).join("\n")}`,
        );
    }
  }
  return !hasError;
}

function getExportedTypes(
  filePath: string,
  program: ts.Program,
  checker: ts.TypeChecker,
): Record<string, ts.Type> {
  const sourceFile = program.getSourceFile(filePath);
  const types: Record<string, ts.Type> = {};
  if (!sourceFile) return types;
  ts.forEachChild(sourceFile, (node) => {
    // Check for @category Guest API in jsdoc
    let isGuestApi = false;
    const jsDocs = ts.getJSDocTags(node);
    for (const tag of jsDocs) {
      if (
        tag.tagName &&
        tag.tagName.text === "category" &&
        typeof tag.comment === "string" &&
        tag.comment.includes("Guest API")
      ) {
        isGuestApi = true;
        break;
      }
    }
    if (
      (ts.isInterfaceDeclaration(node) ||
        ts.isClassDeclaration(node) ||
        ts.isTypeAliasDeclaration(node)) &&
      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      const symbol = checker.getSymbolAtLocation(node.name);
      if (symbol) {
        const type = ts.isTypeAliasDeclaration(node)
          ? checker.getDeclaredTypeOfSymbol(symbol)
          : checker.getTypeOfSymbolAtLocation(symbol, symbol.declarations?.[0]);
        (type as any).__isGuestApi = isGuestApi;
        types[node.name!.text] = type;
      }
    }
  });
  return types;
}

function compareTypes(
  typeA: ts.Type,
  typeB: ts.Type,
  checker: ts.TypeChecker,
  path: string[],
  verbose?: boolean,
  isGuestApiContext?: boolean,
): string[] {
  const errors: string[] = [];
  const propsA = checker.getPropertiesOfType(typeA);
  const propsB = checker.getPropertiesOfType(typeB);
  // Check if this type or any parent in the path is marked as Guest API
  // Do NOT depend on property/type names, only on the Guest API tag
  let guestApiRoot: any = typeA;
  // Unwrap type references to get to the root type
  const seen = new Set();
  while (guestApiRoot && (guestApiRoot.target || guestApiRoot.aliasSymbol)) {
    if (seen.has(guestApiRoot)) break; // prevent infinite loop
    seen.add(guestApiRoot);
    if (guestApiRoot.target) {
      guestApiRoot = guestApiRoot.target;
    } else if (
      guestApiRoot.aliasSymbol &&
      guestApiRoot.aliasTypeArguments &&
      guestApiRoot.aliasTypeArguments.length
    ) {
      guestApiRoot = guestApiRoot.aliasTypeArguments[0];
    } else {
      break;
    }
  }
  // Also check for __isGuestApi on the type itself (for non-alias, non-reference types)
  const isGuestApi =
    (guestApiRoot && guestApiRoot.__isGuestApi === true) ||
    (typeA && (typeA as any).__isGuestApi === true);
  // Propagate Guest API context from parent or self
  const guestApiContext = isGuestApiContext || isGuestApi;
  if (!propsA.length && !propsB.length) {
    // --- Always check for union reduction, even if type aliases match ---
    if (typeA.isUnion() && typeB.isUnion()) {
      const missing = typeA.types.filter(
        (a) =>
          !typeB.types.some(
            (b) => checker.typeToString(a) === checker.typeToString(b),
          ),
      );
      if (missing.length)
        errors.push(
          `Type '${path.join(".") || "<root>"}' in current version is missing union members: ${missing.map((m) => checker.typeToString(m)).join(", ")}`,
        );
      return errors;
    }
    // Handle generics: if both are type aliases and their string representations match, treat as compatible
    if (typeA.aliasSymbol && typeB.aliasSymbol) {
      if (checker.typeToString(typeA) === checker.typeToString(typeB)) {
        return errors;
      }
    }
    if (typeA.getCallSignatures && typeB.getCallSignatures) {
      errors.push(
        ...compareFunctionSignatures(typeA, typeB, checker, path, verbose),
      );
    }
    if (!checker.isTypeAssignableTo(typeB, typeA)) {
      errors.push(
        `Type '${path.join(".") || "<root>"}' in current version is not assignable to previous version (expected: ${checker.typeToString(typeA)}, got: ${checker.typeToString(typeB)})`,
      );
    }
    return errors;
  }
  for (const propA of propsA) {
    const name = propA.getName();
    if (name.startsWith("__@") || name === Symbol.iterator.toString()) continue;
    const propB = typeB.getProperty(name);
    const currentPath = [...path, name];
    if (!propB) {
      errors.push(
        `Property '${currentPath.join(".")}' is missing in current version`,
      );
      if (verbose)
        console.error(
          `[VERBOSE] Property '${currentPath.join(".")}' is missing in current version`,
        );
      continue;
    }
    const typeAProp = propA.declarations?.[0]
      ? checker.getTypeAtLocation(propA.declarations[0])
      : checker.getAnyType();
    const typeBProp = propB.declarations?.[0]
      ? checker.getTypeAtLocation(propB.declarations[0])
      : checker.getAnyType();
    const isOptionalA = (propA.flags & ts.SymbolFlags.Optional) !== 0;
    const isOptionalB = (propB.flags & ts.SymbolFlags.Optional) !== 0;
    if (isOptionalA && !isOptionalB) {
      errors.push(
        `Property '${currentPath.join(".")}' was optional in previous version but is required in current version`,
      );
      if (verbose)
        console.error(
          `[VERBOSE] Property '${currentPath.join(".")}' was optional in previous version but is required in current version`,
        );
    }
    if (typeAProp.getCallSignatures && typeBProp.getCallSignatures) {
      errors.push(
        ...compareFunctionSignatures(
          typeAProp,
          typeBProp,
          checker,
          currentPath,
          verbose,
        ),
      );
    }
    errors.push(
      ...compareTypes(
        typeAProp,
        typeBProp,
        checker,
        currentPath,
        verbose,
        guestApiContext,
      ),
    );
  }
  for (const propB of propsB) {
    const name = propB.getName();
    if (name.startsWith("__@") || name === Symbol.iterator.toString()) continue;
    const propA = typeA.getProperty(name);
    const isOptionalB = (propB.flags & ts.SymbolFlags.Optional) !== 0;
    // Only allow required property addition if neither typeA nor typeB is marked as Guest API
    // Unwrap type references for typeB to get to the root type
    let guestApiRootB: any = typeB;
    const seenB = new Set();
    while (guestApiRootB && (guestApiRootB as any).target) {
      if (seenB.has(guestApiRootB)) break;
      seenB.add(guestApiRootB);
      guestApiRootB = (guestApiRootB as any).target;
    }
    const isGuestApiB =
      (guestApiRootB && (guestApiRootB as any).__isGuestApi === true) ||
      (typeB && (typeB as any).__isGuestApi === true);
    if (!propA && !isOptionalB && !guestApiContext) {
      errors.push(
        `Property '${[...path, name].join(".")}' is required in current version but did not exist in previous version (added required property)`,
      );
      if (verbose)
        console.error(
          `[VERBOSE] Property '${[...path, name].join(".")}' is required in current version but did not exist in previous version (added required property)`,
        );
    }
  }
  return errors;
}

function compareFunctionSignatures(
  typeA: ts.Type,
  typeB: ts.Type,
  checker: ts.TypeChecker,
  path: string[],
  verbose?: boolean,
): string[] {
  const errors: string[] = [];
  const sigsA = typeA
    .getCallSignatures()
    .filter((sig) => !isSignatureFromLib(sig));
  const sigsB = typeB
    .getCallSignatures()
    .filter((sig) => !isSignatureFromLib(sig));
  if (!sigsA.length || !sigsB.length) return errors;
  sigsA.forEach((sigA) => {
    const paramsA = sigA.getParameters();
    sigsB.forEach((sigB) => {
      const paramsB = sigB.getParameters();
      for (let i = 0; i < Math.max(paramsA.length, paramsB.length); i++) {
        const paramA = paramsA[i];
        const paramB = paramsB[i];
        if (paramA && paramB) {
          const isOptA =
            paramA.valueDeclaration &&
            ts.isParameter(paramA.valueDeclaration) &&
            !!paramA.valueDeclaration.questionToken;
          const isOptB =
            paramB.valueDeclaration &&
            ts.isParameter(paramB.valueDeclaration) &&
            !!paramB.valueDeclaration.questionToken;
          if (isOptA && !isOptB) {
            errors.push(
              `Function argument '${path.join(".") || "<root>"}.${paramA.getName()}' was optional in previous version but is required in current version`,
            );
            if (verbose)
              console.error(
                `[VERBOSE] Function argument '${path.join(".") || "<root>"}.${paramA.getName()}' was optional in previous version but is required in current version`,
              );
          }
          if (!isOptA && isOptB) {
            errors.push(
              `Function argument '${path.join(".") || "<root>"}.${paramA.getName()}' was required in previous version but is optional in current version`,
            );
            if (verbose)
              console.error(
                `[VERBOSE] Function argument '${path.join(".") || "<root>"}.${paramA.getName()}' was required in previous version but is optional in current version`,
              );
          }
        } else if (paramA && !paramB) {
          const isOptA =
            paramA.valueDeclaration &&
            ts.isParameter(paramA.valueDeclaration) &&
            !!paramA.valueDeclaration.questionToken;
          if (!isOptA) {
            errors.push(
              `Function argument '${path.join(".") || "<root>"}.${paramA.getName()}' was required in previous version but is missing in current version`,
            );
            if (verbose)
              console.error(
                `[VERBOSE] Function argument '${path.join(".") || "<root>"}.${paramA.getName()}' was required in previous version but is missing in current version`,
              );
          }
        } else if (!paramA && paramB) {
          const isOptB =
            paramB.valueDeclaration &&
            ts.isParameter(paramB.valueDeclaration) &&
            !!paramB.valueDeclaration.questionToken;
          if (!isOptB) {
            errors.push(
              `Function argument '${path.join(".") || "<root>"}.${paramB.getName()}' is required in current version but did not exist in previous version`,
            );
            if (verbose)
              console.error(
                `[VERBOSE] Function argument '${path.join(".") || "<root>"}.${paramB.getName()}' is required in current version but did not exist in previous version`,
              );
          }
        }
      }
    });
  });
  // Check return type regression
  sigsA.forEach((sigA) => {
    sigsB.forEach((sigB) => {
      const retA = checker.getReturnTypeOfSignature(sigA);
      const retB = checker.getReturnTypeOfSignature(sigB);
      if (!checker.isTypeAssignableTo(retB, retA)) {
        errors.push(
          `Function return type at '${path.join(".") || "<root>"}' regressed: expected ${checker.typeToString(retA)}, got ${checker.typeToString(retB)}`,
        );
        if (verbose)
          console.error(
            `[VERBOSE] Function return type at '${path.join(".") || "<root>"}' regressed: expected ${checker.typeToString(retA)}, got ${checker.typeToString(retB)}`,
          );
      }
    });
  });
  return errors;
}

function isSignatureFromLib(sig: ts.Signature): boolean {
  const decl = sig.getDeclaration();
  if (!decl) return false;
  const file = decl.getSourceFile().fileName;
  return file.includes("node_modules/typescript/lib");
}
